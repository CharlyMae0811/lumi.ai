<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fog Sphere â€“ Minimal</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f14;color:#eaf4ff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:24px}
  #fog{width:420px;height:420px;display:block;filter:drop-shadow(0 20px 60px rgba(124,211,255,.25))}
  .row{display:flex;align-items:center;gap:10px}
  button{background:#17324d;border:1px solid rgba(124,211,255,.45);color:#dff1ff;border-radius:10px;padding:10px 14px;cursor:pointer}
  #status{opacity:.8}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="fog" width="420" height="420"></canvas>

  <div class="row">
    <button id="micBtn">ðŸŽ¤ Enable mic pulse</button>
    <span id="status">mic: off</span>
  </div>
</div>

<script>
/* ====== Minimal foggy sphere with mic-reactive pulse ====== */
const canvas = document.getElementById('fog');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const CX = W/2, CY = H/2;
let R = Math.min(W,H)*0.42;

let audioCtx, analyser, micStream;
let amp = 0; // smoothed amplitude 0..1

// Simple RMS amplitude; works cross-browser
function readAmplitude() {
  if (!analyser) return 0;
  const buf = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buf);
  let sum=0;
  for (let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
  const rms = Math.sqrt(sum/buf.length);      // ~0..0.7
  return Math.min(1, rms*3);                  // scale
}

// Random blobs that swirl to create fog
const blobs = Array.from({length: 24}, () => ({
  baseA: Math.random()*Math.PI*2,
  baseR: 0.18 + Math.random()*0.70,
  size:  0.10 + Math.random()*0.30,
  speed: (0.2 + Math.random()*0.6) * (Math.random()<0.5?-1:1),
  wobble: 0.15 + Math.random()*0.4
}));

function mix(a,b,t){ return a + (b-a)*t; }

let t0 = performance.now();
function draw(){
  requestAnimationFrame(draw);
  const t = (performance.now() - t0)/1000;

  // breathing fallback (works even without mic), overridden by mic if present
  const fallback = 0.25 + 0.20*Math.sin(t*1.2);
  const micVal = readAmplitude();
  const target = micVal || fallback;
  amp = amp*0.85 + target*0.15;

  const rNow = R * (1 + 0.07*amp);

  ctx.clearRect(0,0,W,H);

  // Clip to sphere
  ctx.save();
  ctx.beginPath();
  ctx.arc(CX, CY, rNow, 0, Math.PI*2);
  ctx.clip();

  // Base radial glow (blue core â†’ transparent)
  const baseGrad = ctx.createRadialGradient(CX,CY, rNow*0.15, CX,CY, rNow);
  baseGrad.addColorStop(0, 'rgba(120,190,255,0.35)');
  baseGrad.addColorStop(1, 'rgba(120,190,255,0.00)');
  ctx.fillStyle = baseGrad;
  ctx.fillRect(CX-rNow, CY-rNow, rNow*2, rNow*2);

  // Fog blobs
  ctx.globalCompositeOperation = 'lighter';
  for(const b of blobs){
    const a  = b.baseA + b.speed*t + Math.sin(t*0.8 + b.baseA)*0.25*b.wobble;
    const rr = b.baseR * (1 + 0.06*Math.sin(t*0.9 + b.baseA));
    const x  = CX + Math.cos(a) * rr * (rNow*0.95);
    const y  = CY + Math.sin(a) * rr * (rNow*0.95);
    const rad= rNow * b.size * (1 + 0.45*amp);

    // inner = blue, outer = lavender
    const cMix = Math.min(1, Math.max(0, rr+0.2));
    const r = Math.floor(mix( 90,160, cMix));
    const g = Math.floor(mix(160,130, cMix));
    const bl= 255; // keep blue channel high

    const g2 = ctx.createRadialGradient(x,y, rad*0.2, x,y, rad);
    g2.addColorStop(0, `rgba(${r},${g},${bl}, ${0.22 + 0.26*amp})`);
    g2.addColorStop(1, `rgba(${r},${g},${bl}, 0)`);
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();

  // Soft rim / outer glow
  ctx.beginPath();
  ctx.arc(CX, CY, rNow, 0, Math.PI*2);
  ctx.shadowBlur = 40 + amp*80;
  ctx.shadowColor = 'rgba(124,211,255,0.35)';
  ctx.strokeStyle = 'rgba(124,211,255,0.12)';
  ctx.lineWidth = 2;
  ctx.stroke();
}
draw();

// === Mic enable button ===
const micBtn = document.getElementById('micBtn');
const statusEl = document.getElementById('status');

micBtn.addEventListener('click', async () => {
  try{
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      statusEl.textContent = 'mic: not supported';
      return;
    }
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const src = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.8;
    analyser.minDecibels = -90;
    analyser.maxDecibels = -10;
    src.connect(analyser);
    statusEl.textContent = 'mic: on (speak and watch pulse)';
  }catch(e){
    console.error(e);
    statusEl.textContent = 'mic: blocked (check HTTPS & permission)';
  }
});
</script>
</body>
</html>

